defmodule Packmatic.Source.Stream do
  @moduledoc """
  Represents content generated by enumerating a Stream, which returns IO Lists.

  Any data type that implements `Enumerable` can be used as the Initialisation Argument for this
  Source. Usually this would be a Stream that you have created elsewhere.

  In case the data type needs to be dynamically generated, you can instead use a Dynamic source,
  i.e. `Packmatic.Source.Dynamic`, and build the actual enum there.
  """

  alias Packmatic.Source
  @behaviour Source

  @type init_arg :: Enumerable.t()
  @type init_result :: {:ok, t}
  @spec init(init_arg) :: init_result

  @type t :: %__MODULE__{agent_pid: pid()}
  @enforce_keys ~w(agent_pid)a
  defstruct agent_pid: nil

  @impl Source
  def validate(init_arg) do
    case Enumerable.impl_for(init_arg) do
      nil -> {:error, :invalid}
      _ -> :ok
    end
  end

  @impl Source
  def init(enum) do
    reduce_fun = fn item, _acc -> {:suspend, item} end
    {:suspended, nil, continuation} = Enumerable.reduce(enum, {:suspend, nil}, reduce_fun)
    {:ok, agent_pid} = Agent.start_link(fn -> continuation end)
    {:ok, %__MODULE__{agent_pid: agent_pid}}
  end

  @impl Source
  def read(%{agent_pid: agent_pid}) do
    with true <- Process.alive?(agent_pid) do
      with :eof <- iterate(agent_pid) do
        :ok = Agent.stop(agent_pid)
        :eof
      else
        item -> item
      end
    else
      _ -> {:error, :agent_missing}
    end
  end

  defp iterate(agent_pid) do
    Agent.get_and_update(agent_pid, fn continuation ->
      case continuation.({:cont, nil}) do
        {:suspended, item, continuation} -> {item, continuation}
        {:halted, item} -> {item, fn _ -> {:done, nil} end}
        {:done, nil} -> {:eof, nil}
      end
    end)
  end
end
